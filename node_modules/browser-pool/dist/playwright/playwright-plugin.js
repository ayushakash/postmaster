"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaywrightPlugin = void 0;
const browser_1 = require("./browser");
const playwright_controller_1 = require("./playwright-controller");
const browser_plugin_1 = require("../abstract-classes/browser-plugin");
const logger_1 = require("../logger");
const proxy_server_1 = require("../proxy-server");
const anonymize_proxy_1 = require("../anonymize-proxy");
class PlaywrightPlugin extends browser_plugin_1.BrowserPlugin {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_browserVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    async _launch(launchContext) {
        const { launchOptions, useIncognitoPages, userDataDir, proxyUrl, } = launchContext;
        let browser;
        // Required for the `proxy` context option to work.
        launchOptions.proxy = {
            server: await (0, proxy_server_1.getLocalProxyAddress)(),
            ...launchOptions.proxy,
        };
        const [anonymizedProxyUrl, close] = await (0, anonymize_proxy_1.anonymizeProxySugar)(proxyUrl);
        if (anonymizedProxyUrl) {
            launchOptions.proxy = {
                server: anonymizedProxyUrl,
                bypass: launchOptions.proxy.bypass,
            };
        }
        try {
            if (useIncognitoPages) {
                browser = await this.library.launch(launchOptions);
                if (anonymizedProxyUrl) {
                    browser.on('disconnected', async () => {
                        await close();
                    });
                }
            }
            else {
                const browserContext = await this.library.launchPersistentContext(userDataDir, launchOptions);
                if (anonymizedProxyUrl) {
                    browserContext.on('close', async () => {
                        await close();
                    });
                }
                if (!this._browserVersion) {
                    // Launches unused browser just to get the browser version.
                    const inactiveBrowser = await this.library.launch(launchOptions);
                    this._browserVersion = inactiveBrowser.version();
                    inactiveBrowser.close().catch((error) => {
                        logger_1.log.exception(error, 'Failed to close browser.');
                    });
                }
                browser = new browser_1.Browser({ browserContext, version: this._browserVersion });
            }
        }
        catch (error) {
            await close();
            throw error;
        }
        return browser;
    }
    _createController() {
        return new playwright_controller_1.PlaywrightController(this);
    }
    async _addProxyToLaunchOptions(launchContext) {
        var _a;
        (_a = launchContext.launchOptions) !== null && _a !== void 0 ? _a : (launchContext.launchOptions = {});
        const { launchOptions, proxyUrl } = launchContext;
        if (proxyUrl) {
            const url = new URL(proxyUrl);
            launchOptions.proxy = {
                server: url.origin,
                username: decodeURIComponent(url.username),
                password: decodeURIComponent(url.password),
            };
        }
    }
    _isChromiumBasedBrowser() {
        const name = this.library.name();
        return name === 'chromium';
    }
}
exports.PlaywrightPlugin = PlaywrightPlugin;
//# sourceMappingURL=playwright-plugin.js.map